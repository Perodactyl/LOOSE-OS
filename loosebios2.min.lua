--This code is available under the GNU GPLv3 license. <https://www.gnu.org/licenses/gpl-3.0.en.html>
do _G._BIOSVERSION="Loose BIOS v0.2.1"_G._BIOS_VERSION="Loose BIOS v0.2.1"_G._LOOSE_LOG=""_G._LOOSE=true;_G._BOOT_ADDR=""local function a(b)local c=component.list(b)()if c~=nil then return component.proxy(c)else return nil end end;local d=a("screen")local e=a("gpu")local f=a("eeprom")f.setLabel(_G._BIOS_VERSION)function _G.computer.getBootAddress()if not f then return nil end;return f.getData()end;function _G.computer.setBootAddress(g)if f then f.setData(g)end end;local h,i,j,k;if d~=nil and e~=nil then e.bind(d.address)h,i,j,k=1,1,e.getViewport()end;local function l()if e then e.copy(1,1,j,k,0,-1)e.fill(1,k-1,j,1," ")end end;local function m(n)_LOOSE_LOG=_LOOSE_LOG..n;if not e then return end;for o=1,#n do local p=n:sub(o,o)if h>=j or p=="\n"then h=0;i=i+1 end;if i>=k or p=="\v"then i=k-1;l()end;e.set(h,i,p)h=h+1 end end;local function q(n)m(tostring(n).."\n")end;local function r(h,i,j,k,s)if e then e.fill(h,i,j,k,s)end end;local function t(t)if e and e.getDepth()>1 then e.setForeground(t)end end;local u=0xFFFFFF;local v=0xFF0000;local w=0x00FF00;local x=0x0000FF;local y=0x00FFFF;local z=0xFF00FF;local A=0xFFFF00;local function B(C)t(A)q(C)t(u)end;local function D(C)t(v)q(C)t(u)end;_G._LOOSE_WRITE=m;_G._LOOSE_PRINT=q;_G._LOOSE_WARN=B;_G._LOOSE_ERR=D;r(1,1,j,k," ")q("Size: "..j..", "..k)m("-- ")t(v)m("Loose BIOS v0.2.1")t(u)q(" --")local E={}local F=nil;local G=""local H={"/init.lua","/startup.lua","/boot/init.lua","/boot/startup.lua","/autorun.lua"}local I={}local function J(K,L)if type(K)~="string"or#K<=0 then D(L)D("Invalid Bootcode ("..type(K).."): "..tostring(K))return end;local M,N=load(K,"Bootcode","bt",_G)if not M then D("Failed to load bootcode")D(L)D(N)return end;_G.BOOT_FN=J;local O,P=pcall(M)if O then D("Failed to execute bootcode")D(L)D(P)end end;function E.buf(Q)G=G..Q.."\n"end;function E.run()E.lua(G)end;function E.clear()G=""end;function E.lua(K)local D,P=pcall(function()load(K)()end)if D then D("Error executing lua: "..K)D(P)end end;function E.addf(Q)table.insert(H,Q)end;function E.remf(Q)for o,R in pairs(H)do if R==Q then table.remove(H,o)break end end end;function E.search(S)if type(S)=="string"then S=S=="true"end;if not S then q("Searching filesystems...")q(" |ID"..(" "):rep(35).."|CTL|Bootable"..(" "):rep(37).."|")end;for T in component.list("filesystem")do local U=component.proxy(T)if not S then t(x)m("  "..T.."  ")if U and U.isReadOnly()then t(v)m("RO  ")elseif U then t(w)m("RW  ")else t(z)m("??  ")end end;if U then local V=nil;for o,W in ipairs(H)do if U.exists(W)then if not S then t(w)m("Y: ")t(y)q(W)end;V=W;break end end;if not V and not S then t(v)q("N")elseif V then table.insert(I,{T,V})end elseif not S then t(A)q("UNKNOWN FS")end end;if not S then t(u)end end;local X=nil;local V=nil;function E.fs(Q)X=Q;if X and V then table.insert(I,{X,V})X=nil;V=nil end end;function E.path(Q)V=Q;if X and V then table.insert(I,{X,V})X=nil;V=nil end end;function E.boot(Q)Q=tonumber(Q)if not Q then Q=1 end;if Q>#I or Q<1 then B("WARN: Option out of bounds (1,"..#I.."): "..Q)return end;local c,W=table.unpack(I[Q])local Y=c..W;_G._BOOT_ADDR=c;t(A)m("Booting ")t(z)m(c)t(y)q(W)local T=component.proxy(c)if not T then B("WARN: Invalid FS of id: "..c)return end;local Z=T.open(W,"r")local K=""local K=""while true do local _=T.read(Z,2048)if _==nil then break end;K=K.._ end;T.close(Z)J(K,"Crashed when running code from "..Y)end;function E.choose(a0)if#I==1 then q("Only one option to choose from, booting...")E.boot("1")return end;local a1,N=pcall(function()if not e then q("No GPU")return end;q("Selecting boot source...")local a2=1;local a3=i-1;local a4=0;local a5=computer.uptime()local a6=false;while not a6 do local a7={}table.insert(a7,{0xffffff,0x000000,"Select boot source:"})for o,n in pairs(I)do local c,a8=table.unpack(n)if o==a2 then if e.getDepth()>1 then e.setBackground(0xAAAAAA)e.setForeground(0x111111)elseif e then e.setBackground(0xFFFFFF)e.setForeground(0x000000)end else e.setBackground(0x000000)e.setForeground(0xFFFFFF)end;local component=component.proxy(c)if component then local a9="RW"if component.isReadOnly()then a9="RO"end;table.insert(a7,{e.getForeground(),e.getBackground(),"("..a9 ..") "..c..": "..a8})else table.insert(a7,{e.getForeground(),e.getBackground(),"(??) "..c..": (COMPONENT MISSING)"})end end;for o=1,math.max(#a7,a4)do if o<=#a7 then local aa,ab,ac=table.unpack(a7[o])local ad=(" "):rep(j-#ac)e.setForeground(aa)e.setBackground(ab)e.set(1,a3+o,ac)else e.setBackground(0x000000)e.set(1,a3+o,(" "):rep(j))end end;a4=#a7;while true do local ae={computer.pullSignal()}if ae[1]~=nil then local af=ae[1]=="component_added"or ae[1]=="component_removed"if af and a0=="true"and ae[3]=="filesystem"then I={}E.search("true")end;if ae[1]=="key_down"then local ag,ag,ag,ah,ag=table.unpack(ae)if ah==200 or ah==17 then a2=a2-1 elseif ah==208 or ah==31 then a2=a2+1 elseif ah==57 or ah==28 then q("Booted option #"..a2 .."( disk id "..I[a2][1]..", file "..I[a2][2]..")")E.boot(tostring(a2))a6=true;break end end;break end end end end)if not a1 then t(A)q("Disk selector crashed.")q("This may be a result of removing a disk.")q("The system will now reboot.")local ai=computer.uptime()computer.pushSignal("tick_pause")computer.pullSignal()while computer.uptime()-ai<1 do end;computer.shutdown(true)end end;function E.parse(K)if type(K)~="string"then D("Failed to parse directives: Not a string ("..type(K).."): "..tostring(K))return end;local a7={}local aj=""for o=1,#K do local p=K:sub(o,o)if p=="\n"or p==";"then table.insert(a7,aj)aj=""else aj=aj..p end end;if#aj>0 then table.insert(a7,aj)end;for o,ac in ipairs(a7)do for ak,al in pairs(E)do if string.find(ac,ak)then local ai,am=string.find(ac,ak)if am~=nil then local Q=ac:sub(am+1,-1)al(Q)else al()end;break end end end end;E.search("true")E.choose("true")computer.pullSignal(1)B("\nWARN: Loose BIOS reached end of execution thread")while true do coroutine.yield()end end